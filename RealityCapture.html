<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.0" />
<title>adeskForgeWrapper.RealityCapture API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>adeskForgeWrapper.RealityCapture</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .client import checkScopes
from .client import checkResponse
from .urls import RECAP_API
from . import client
from . import fpwExceptions
import os

import requests

class PhotosceneCreationOptions(object):
    &#39;&#39;&#39;Class used to organize request options for this module&#39;&#39;&#39;
    def __init__(self, scenename: str, callback = None, Format = &#34;rcm&#34;, scenetype = &#34;aerial&#34;, gpstype = None, hubprojectid = None,
                hubfolderid = None, version = &#34;2.0&#34;, metadata = None):
        if scenetype != &#34;aerial&#34;:
            if Format == &#34;rcs&#34; or Format== &#34;ortho&#34; or Format == &#34;report&#34;:
                raise fpwExceptions.forgeException(&#34;That format parameter is only available if scenetype is set to aerial&#34;)

            elif gpstype != None:
                pass #TODO Check 

            elif metadata != None:
                raise fpwExceptions.forgeException(&#34;Metadata fine tuning parameters are available only if scenetype is set to aerial&#34;)

        if &#34;http://&#34; in callback or &#34;https://&#34; in callback:
            self.callback = callback
        else:
            self.callback = &#34;email://{}&#34;.format(callback)
        self.scenename = scenename
        self.Format = Format
        self.scenetype = scenetype
        self.gpstype = gpstype
        self.hubprojectid = hubprojectid
        self.hubfolderid = hubfolderid
        self.version = version
        self.metadata = metadata

    @classmethod
    def defaultObjectScene(cls):
        return cls(scenename=&#34;afwDefaultObject&#34;, scenetype=&#34;object&#34;)



class Photoscene(object):
    &#39;&#39;&#39;A “photoscene” entity provides a common representation of a photo-to-3D project. &lt;br&gt;
    Certain fields will only be available after processing is complete.
    Photoscene.raw&lt;br&gt;
    Photoscene.scenename&lt;br&gt;
    Photoscene.callback&lt;br&gt;
    Photoscene.format&lt;br&gt;
    Photoscene.scenetype&lt;br&gt;
    Photoscene.gpstype&lt;br&gt;
    Photoscene.hubprojectid&lt;br&gt;
    Photoscene.hubfolderid&lt;br&gt;
    Photoscene.version&lt;br&gt;
    Photoscene.metadata&lt;br&gt;&#39;&#39;&#39;
    def __init__(self, rawDict, Id):
        self.__raw = rawDict
        self.__scenename = rawDict.get(&#34;scenename&#34;) or None
        self.__callback = rawDict.get(&#34;callback&#34;) or None
        self.__format = rawDict.get(&#34;format&#34;) or None
        self.__scenetype = rawDict.get(&#34;scenetype&#34;) or None
        self.__gpstype = rawDict.get(&#34;gpstype&#34;) or None
        self.__hubprojectid = rawDict.get(&#34;hubprojectid&#34;) or None
        self.__hubfolderid = rawDict.get(&#34;hubfolderid&#34;) or None
        self.__version = rawDict.get(&#34;version&#34;) or None
        self.__metadata = rawDict.get(&#34;metadata&#34;) or None
        self.__Id = rawDict.get(&#34;photosceneid&#34;) or Id
    
    @property
    def raw(self):
        return self.__raw
    @property
    def Id(self):
        return self.__Id
    @property
    def scenename(self):
        return self.__scenename
    @property
    def callback(self):
        return self.__callback
    @property
    def format(self):
        return self.__format
    @property
    def scenetype(self):
        return self.__scenetype
    @property
    def gpstype(self):
        return self.__gpstype
    @property
    def hubprojectid(self):
        return self.__hubprojectid
    @property
    def hubfolderid(self):
        return self.__hubfolderid
    @property
    def version(self):
        return self.__version
    @property
    def metadata(self):
        return self.__metadata

    @classmethod
    def psById(cls, PhotosceneId):
        rawDict = {
        &#34;Photoscene&#34;: {
        &#34;photosceneid&#34;: PhotosceneId
                      }
         }
        return cls(rawDict, PhotosceneId)
    
    @classmethod
    def create(cls, token: client.Token, psOptions: PhotosceneCreationOptions):
        &#39;&#39;&#39;Creates and initializes a photoscene for reconstruction.&lt;br&gt;
        Scope data:write&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        data = {
        &#34;scenename&#34; : psOptions.scenename,
        &#34;callback&#34; : psOptions.callback,
        &#34;format&#34;: psOptions.Format,
        &#34;scenetype&#34; : psOptions.scenetype,
        &#34;gpstype&#34; : psOptions.gpstype,
        &#34;hubprojectid&#34; : psOptions.hubprojectid,
        &#34;hubfolderid&#34; : psOptions.hubfolderid,
        &#34;version&#34; : psOptions.version,
        &#34;metadata&#34; : psOptions.metadata
        }
        data = {k : v for k,v in data.items() if v is not None}
        endpointUrl = RECAP_API+&#34;/photoscene&#34;
        r = requests.post(endpointUrl, headers=token.urlEncoded, data=data).json()
        checkResponse(r)
        print(&#34;Photoscene ID:&#34;, r.get(&#34;photosceneid&#34;))
        return cls(r, data)
    
    def uploadFiles(self, token: client.Token):
        &#39;&#39;&#39;Adds one or more files to a photoscene.&lt;br&gt;
        Scope data:write&lt;br&gt;&lt;br&gt;
        Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
        Although uploading multiple files at the same time might be more efficient, you should limit the number 
        of files per request depending on your available bandwidth to avoid timeouts.&lt;br&gt;
        Note: Uploaded files will be deleted after 30 days.&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        import tkinter as tk
        from tkinter import filedialog
        application_window = tk.Tk()
        application_window.withdraw()
        answer = filedialog.askopenfilenames(parent=application_window,
                                            initialdir=os.getcwd(),
                                            title=&#34;Please select one or more files:&#34;,
                                            filetypes=[(&#34;Image files&#34;, &#34;.jpg .jpeg&#34;)])
        if answer != &#34;&#34;:
            payload = {&#39;photosceneid&#39;:self.Id, &#39;type&#39;: &#39;image&#39;}
            files = []
            n=-1
            for a in answer:
                n = n+1
                a = a.replace(&#34;/&#34;, &#34;\\&#34;)
                files.append((&#34;file[{x}]&#34;.format(x=n), open(a,&#34;rb&#34;)))

                # files[&#34;file[{x}]&#34;.format(x=n)] = (a, open(a,&#34;rb&#34;))
            endpointUrl = RECAP_API+&#34;/file&#34;
            r = requests.post(endpointUrl, headers=token.formData, data=payload, files=files).json()
            if &#34;Error&#34; in r:
                checkResponse(r[&#34;Error&#34;])
            else:
                print(r)

    def startProcessing(self, token: client.Token):
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(r)

    def getProgress(self, token: client.Token):
        &#39;&#39;&#39;Returns the processing progress and status of a photoscene.&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/progress&#34;.format(phId = self.Id)
        r = requests.get(endpointUrl, headers=token.getHeader).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(&#34;{}%&#34;.format(r[&#34;Photoscene&#34;][&#34;progress&#34;]))
            print(r[&#34;Photoscene&#34;][&#34;progressmsg&#34;])

    def deleteScene(self, token: client.Token):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Photoscene successfully deleted&#34;)

    @classmethod
    def deleteSceneById(self, token: client.Token, Id: str):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = Id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            return True

    def getDownloadURL(self, token: client.Token, Format = None):
        &#39;&#39;&#39;Returns a time-limited HTTPS link to an output file of the specified format.&lt;br&gt;
        Note: The link will expire 30 days after the date of processing completion.&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        if Format is None:
            params = (&#34;format&#34;, self.format)
            endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
            r = requests.get(endpointUrl,headers=token.getHeader, params=params).json()
        elif Format is not None:
            params = (&#34;format&#34;, Format)
            endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
            r = requests.get(endpointUrl, headers=token.getHeader, params=params).json()
        print(r) # TODO Review attributes usability

    def cancelProgress(self, token: client.Token):
        &#39;&#39;&#39;Aborts the processing of a photoscene and marks it as cancelled.&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/cancel&#34;.format(phId = self.Id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            return True


__pdoc__ = {}

__pdoc__[&#39;Photoscene.raw&#39;] = False      
__pdoc__[&#39;Photoscene.scenename&#39;] = False
__pdoc__[&#39;Photoscene.callback&#39;] = False 
__pdoc__[&#39;Photoscene.format&#39;] = False   
__pdoc__[&#39;Photoscene.scenetype&#39;] = False
__pdoc__[&#39;Photoscene.gpstype&#39;] = False
__pdoc__[&#39;Photoscene.hubprojectid&#39;] = False
__pdoc__[&#39;Photoscene.hubfolderid&#39;] = False
__pdoc__[&#39;Photoscene.version&#39;] = False
__pdoc__[&#39;Photoscene.metadata&#39;] = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene"><code class="flex name class">
<span>class <span class="ident">Photoscene</span></span>
<span>(</span><span>rawDict, Id)</span>
</code></dt>
<dd>
<div class="desc"><p>A “photoscene” entity provides a common representation of a photo-to-3D project. <br>
Certain fields will only be available after processing is complete.
Photoscene.raw<br>
Photoscene.scenename<br>
Photoscene.callback<br>
Photoscene.format<br>
Photoscene.scenetype<br>
Photoscene.gpstype<br>
Photoscene.hubprojectid<br>
Photoscene.hubfolderid<br>
Photoscene.version<br>
Photoscene.metadata<br></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Photoscene(object):
    &#39;&#39;&#39;A “photoscene” entity provides a common representation of a photo-to-3D project. &lt;br&gt;
    Certain fields will only be available after processing is complete.
    Photoscene.raw&lt;br&gt;
    Photoscene.scenename&lt;br&gt;
    Photoscene.callback&lt;br&gt;
    Photoscene.format&lt;br&gt;
    Photoscene.scenetype&lt;br&gt;
    Photoscene.gpstype&lt;br&gt;
    Photoscene.hubprojectid&lt;br&gt;
    Photoscene.hubfolderid&lt;br&gt;
    Photoscene.version&lt;br&gt;
    Photoscene.metadata&lt;br&gt;&#39;&#39;&#39;
    def __init__(self, rawDict, Id):
        self.__raw = rawDict
        self.__scenename = rawDict.get(&#34;scenename&#34;) or None
        self.__callback = rawDict.get(&#34;callback&#34;) or None
        self.__format = rawDict.get(&#34;format&#34;) or None
        self.__scenetype = rawDict.get(&#34;scenetype&#34;) or None
        self.__gpstype = rawDict.get(&#34;gpstype&#34;) or None
        self.__hubprojectid = rawDict.get(&#34;hubprojectid&#34;) or None
        self.__hubfolderid = rawDict.get(&#34;hubfolderid&#34;) or None
        self.__version = rawDict.get(&#34;version&#34;) or None
        self.__metadata = rawDict.get(&#34;metadata&#34;) or None
        self.__Id = rawDict.get(&#34;photosceneid&#34;) or Id
    
    @property
    def raw(self):
        return self.__raw
    @property
    def Id(self):
        return self.__Id
    @property
    def scenename(self):
        return self.__scenename
    @property
    def callback(self):
        return self.__callback
    @property
    def format(self):
        return self.__format
    @property
    def scenetype(self):
        return self.__scenetype
    @property
    def gpstype(self):
        return self.__gpstype
    @property
    def hubprojectid(self):
        return self.__hubprojectid
    @property
    def hubfolderid(self):
        return self.__hubfolderid
    @property
    def version(self):
        return self.__version
    @property
    def metadata(self):
        return self.__metadata

    @classmethod
    def psById(cls, PhotosceneId):
        rawDict = {
        &#34;Photoscene&#34;: {
        &#34;photosceneid&#34;: PhotosceneId
                      }
         }
        return cls(rawDict, PhotosceneId)
    
    @classmethod
    def create(cls, token: client.Token, psOptions: PhotosceneCreationOptions):
        &#39;&#39;&#39;Creates and initializes a photoscene for reconstruction.&lt;br&gt;
        Scope data:write&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        data = {
        &#34;scenename&#34; : psOptions.scenename,
        &#34;callback&#34; : psOptions.callback,
        &#34;format&#34;: psOptions.Format,
        &#34;scenetype&#34; : psOptions.scenetype,
        &#34;gpstype&#34; : psOptions.gpstype,
        &#34;hubprojectid&#34; : psOptions.hubprojectid,
        &#34;hubfolderid&#34; : psOptions.hubfolderid,
        &#34;version&#34; : psOptions.version,
        &#34;metadata&#34; : psOptions.metadata
        }
        data = {k : v for k,v in data.items() if v is not None}
        endpointUrl = RECAP_API+&#34;/photoscene&#34;
        r = requests.post(endpointUrl, headers=token.urlEncoded, data=data).json()
        checkResponse(r)
        print(&#34;Photoscene ID:&#34;, r.get(&#34;photosceneid&#34;))
        return cls(r, data)
    
    def uploadFiles(self, token: client.Token):
        &#39;&#39;&#39;Adds one or more files to a photoscene.&lt;br&gt;
        Scope data:write&lt;br&gt;&lt;br&gt;
        Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
        Although uploading multiple files at the same time might be more efficient, you should limit the number 
        of files per request depending on your available bandwidth to avoid timeouts.&lt;br&gt;
        Note: Uploaded files will be deleted after 30 days.&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        import tkinter as tk
        from tkinter import filedialog
        application_window = tk.Tk()
        application_window.withdraw()
        answer = filedialog.askopenfilenames(parent=application_window,
                                            initialdir=os.getcwd(),
                                            title=&#34;Please select one or more files:&#34;,
                                            filetypes=[(&#34;Image files&#34;, &#34;.jpg .jpeg&#34;)])
        if answer != &#34;&#34;:
            payload = {&#39;photosceneid&#39;:self.Id, &#39;type&#39;: &#39;image&#39;}
            files = []
            n=-1
            for a in answer:
                n = n+1
                a = a.replace(&#34;/&#34;, &#34;\\&#34;)
                files.append((&#34;file[{x}]&#34;.format(x=n), open(a,&#34;rb&#34;)))

                # files[&#34;file[{x}]&#34;.format(x=n)] = (a, open(a,&#34;rb&#34;))
            endpointUrl = RECAP_API+&#34;/file&#34;
            r = requests.post(endpointUrl, headers=token.formData, data=payload, files=files).json()
            if &#34;Error&#34; in r:
                checkResponse(r[&#34;Error&#34;])
            else:
                print(r)

    def startProcessing(self, token: client.Token):
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(r)

    def getProgress(self, token: client.Token):
        &#39;&#39;&#39;Returns the processing progress and status of a photoscene.&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/progress&#34;.format(phId = self.Id)
        r = requests.get(endpointUrl, headers=token.getHeader).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(&#34;{}%&#34;.format(r[&#34;Photoscene&#34;][&#34;progress&#34;]))
            print(r[&#34;Photoscene&#34;][&#34;progressmsg&#34;])

    def deleteScene(self, token: client.Token):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Photoscene successfully deleted&#34;)

    @classmethod
    def deleteSceneById(self, token: client.Token, Id: str):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = Id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            return True

    def getDownloadURL(self, token: client.Token, Format = None):
        &#39;&#39;&#39;Returns a time-limited HTTPS link to an output file of the specified format.&lt;br&gt;
        Note: The link will expire 30 days after the date of processing completion.&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        if Format is None:
            params = (&#34;format&#34;, self.format)
            endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
            r = requests.get(endpointUrl,headers=token.getHeader, params=params).json()
        elif Format is not None:
            params = (&#34;format&#34;, Format)
            endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
            r = requests.get(endpointUrl, headers=token.getHeader, params=params).json()
        print(r) # TODO Review attributes usability

    def cancelProgress(self, token: client.Token):
        &#39;&#39;&#39;Aborts the processing of a photoscene and marks it as cancelled.&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/cancel&#34;.format(phId = self.Id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            return True</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, psOptions: <a title="adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions" href="#adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions">PhotosceneCreationOptions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and initializes a photoscene for reconstruction.<br>
Scope data:write</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create(cls, token: client.Token, psOptions: PhotosceneCreationOptions):
    &#39;&#39;&#39;Creates and initializes a photoscene for reconstruction.&lt;br&gt;
    Scope data:write&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    data = {
    &#34;scenename&#34; : psOptions.scenename,
    &#34;callback&#34; : psOptions.callback,
    &#34;format&#34;: psOptions.Format,
    &#34;scenetype&#34; : psOptions.scenetype,
    &#34;gpstype&#34; : psOptions.gpstype,
    &#34;hubprojectid&#34; : psOptions.hubprojectid,
    &#34;hubfolderid&#34; : psOptions.hubfolderid,
    &#34;version&#34; : psOptions.version,
    &#34;metadata&#34; : psOptions.metadata
    }
    data = {k : v for k,v in data.items() if v is not None}
    endpointUrl = RECAP_API+&#34;/photoscene&#34;
    r = requests.post(endpointUrl, headers=token.urlEncoded, data=data).json()
    checkResponse(r)
    print(&#34;Photoscene ID:&#34;, r.get(&#34;photosceneid&#34;))
    return cls(r, data)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.deleteSceneById"><code class="name flex">
<span>def <span class="ident">deleteSceneById</span></span>(<span>token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, Id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a photoscene and its associated assets (images, output files, &hellip;).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deleteSceneById(self, token: client.Token, Id: str):
    &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = Id)
    r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    elif r[&#34;msg&#34;] == &#34;No error&#34;:
        return True</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.psById"><code class="name flex">
<span>def <span class="ident">psById</span></span>(<span>PhotosceneId)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def psById(cls, PhotosceneId):
    rawDict = {
    &#34;Photoscene&#34;: {
    &#34;photosceneid&#34;: PhotosceneId
                  }
     }
    return cls(rawDict, PhotosceneId)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.Id"><code class="name">var <span class="ident">Id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Id(self):
    return self.__Id</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.cancelProgress"><code class="name flex">
<span>def <span class="ident">cancelProgress</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Aborts the processing of a photoscene and marks it as cancelled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancelProgress(self, token: client.Token):
    &#39;&#39;&#39;Aborts the processing of a photoscene and marks it as cancelled.&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}/cancel&#34;.format(phId = self.Id)
    r = requests.post(endpointUrl, headers=token.urlEncoded).json()
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    elif r[&#34;msg&#34;] == &#34;No error&#34;:
        return True</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.deleteScene"><code class="name flex">
<span>def <span class="ident">deleteScene</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a photoscene and its associated assets (images, output files, &hellip;).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteScene(self, token: client.Token):
    &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
    r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    elif r[&#34;msg&#34;] == &#34;No error&#34;:
        print(&#34;Photoscene successfully deleted&#34;)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.getDownloadURL"><code class="name flex">
<span>def <span class="ident">getDownloadURL</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, Format=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a time-limited HTTPS link to an output file of the specified format.<br>
Note: The link will expire 30 days after the date of processing completion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDownloadURL(self, token: client.Token, Format = None):
    &#39;&#39;&#39;Returns a time-limited HTTPS link to an output file of the specified format.&lt;br&gt;
    Note: The link will expire 30 days after the date of processing completion.&#39;&#39;&#39;
    checkScopes(token, &#34;data:read&#34;)
    if Format is None:
        params = (&#34;format&#34;, self.format)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
        r = requests.get(endpointUrl,headers=token.getHeader, params=params).json()
    elif Format is not None:
        params = (&#34;format&#34;, Format)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
        r = requests.get(endpointUrl, headers=token.getHeader, params=params).json()
    print(r) # TODO Review attributes usability</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.getProgress"><code class="name flex">
<span>def <span class="ident">getProgress</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the processing progress and status of a photoscene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProgress(self, token: client.Token):
    &#39;&#39;&#39;Returns the processing progress and status of a photoscene.&#39;&#39;&#39;
    checkScopes(token, &#34;data:read&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}/progress&#34;.format(phId = self.Id)
    r = requests.get(endpointUrl, headers=token.getHeader).json()
    checkResponse(r)
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    else:
        print(&#34;{}%&#34;.format(r[&#34;Photoscene&#34;][&#34;progress&#34;]))
        print(r[&#34;Photoscene&#34;][&#34;progressmsg&#34;])</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.startProcessing"><code class="name flex">
<span>def <span class="ident">startProcessing</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startProcessing(self, token: client.Token):
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.Id)
    r = requests.post(endpointUrl, headers=token.urlEncoded).json()
    checkResponse(r)
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    else:
        print(r)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.Photoscene.uploadFiles"><code class="name flex">
<span>def <span class="ident">uploadFiles</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more files to a photoscene.<br>
Scope data:write<br><br>
Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
Although uploading multiple files at the same time might be more efficient, you should limit the number
of files per request depending on your available bandwidth to avoid timeouts.<br>
Note: Uploaded files will be deleted after 30 days.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uploadFiles(self, token: client.Token):
    &#39;&#39;&#39;Adds one or more files to a photoscene.&lt;br&gt;
    Scope data:write&lt;br&gt;&lt;br&gt;
    Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
    Although uploading multiple files at the same time might be more efficient, you should limit the number 
    of files per request depending on your available bandwidth to avoid timeouts.&lt;br&gt;
    Note: Uploaded files will be deleted after 30 days.&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    import tkinter as tk
    from tkinter import filedialog
    application_window = tk.Tk()
    application_window.withdraw()
    answer = filedialog.askopenfilenames(parent=application_window,
                                        initialdir=os.getcwd(),
                                        title=&#34;Please select one or more files:&#34;,
                                        filetypes=[(&#34;Image files&#34;, &#34;.jpg .jpeg&#34;)])
    if answer != &#34;&#34;:
        payload = {&#39;photosceneid&#39;:self.Id, &#39;type&#39;: &#39;image&#39;}
        files = []
        n=-1
        for a in answer:
            n = n+1
            a = a.replace(&#34;/&#34;, &#34;\\&#34;)
            files.append((&#34;file[{x}]&#34;.format(x=n), open(a,&#34;rb&#34;)))

            # files[&#34;file[{x}]&#34;.format(x=n)] = (a, open(a,&#34;rb&#34;))
        endpointUrl = RECAP_API+&#34;/file&#34;
        r = requests.post(endpointUrl, headers=token.formData, data=payload, files=files).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(r)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions"><code class="flex name class">
<span>class <span class="ident">PhotosceneCreationOptions</span></span>
<span>(</span><span>scenename: str, callback=None, Format='rcm', scenetype='aerial', gpstype=None, hubprojectid=None, hubfolderid=None, version='2.0', metadata=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to organize request options for this module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhotosceneCreationOptions(object):
    &#39;&#39;&#39;Class used to organize request options for this module&#39;&#39;&#39;
    def __init__(self, scenename: str, callback = None, Format = &#34;rcm&#34;, scenetype = &#34;aerial&#34;, gpstype = None, hubprojectid = None,
                hubfolderid = None, version = &#34;2.0&#34;, metadata = None):
        if scenetype != &#34;aerial&#34;:
            if Format == &#34;rcs&#34; or Format== &#34;ortho&#34; or Format == &#34;report&#34;:
                raise fpwExceptions.forgeException(&#34;That format parameter is only available if scenetype is set to aerial&#34;)

            elif gpstype != None:
                pass #TODO Check 

            elif metadata != None:
                raise fpwExceptions.forgeException(&#34;Metadata fine tuning parameters are available only if scenetype is set to aerial&#34;)

        if &#34;http://&#34; in callback or &#34;https://&#34; in callback:
            self.callback = callback
        else:
            self.callback = &#34;email://{}&#34;.format(callback)
        self.scenename = scenename
        self.Format = Format
        self.scenetype = scenetype
        self.gpstype = gpstype
        self.hubprojectid = hubprojectid
        self.hubfolderid = hubfolderid
        self.version = version
        self.metadata = metadata

    @classmethod
    def defaultObjectScene(cls):
        return cls(scenename=&#34;afwDefaultObject&#34;, scenetype=&#34;object&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions.defaultObjectScene"><code class="name flex">
<span>def <span class="ident">defaultObjectScene</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def defaultObjectScene(cls):
    return cls(scenename=&#34;afwDefaultObject&#34;, scenetype=&#34;object&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="adeskForgeWrapper" href="index.html">adeskForgeWrapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="adeskForgeWrapper.RealityCapture.Photoscene" href="#adeskForgeWrapper.RealityCapture.Photoscene">Photoscene</a></code></h4>
<ul class="two-column">
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.Id" href="#adeskForgeWrapper.RealityCapture.Photoscene.Id">Id</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.cancelProgress" href="#adeskForgeWrapper.RealityCapture.Photoscene.cancelProgress">cancelProgress</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.create" href="#adeskForgeWrapper.RealityCapture.Photoscene.create">create</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.deleteScene" href="#adeskForgeWrapper.RealityCapture.Photoscene.deleteScene">deleteScene</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.deleteSceneById" href="#adeskForgeWrapper.RealityCapture.Photoscene.deleteSceneById">deleteSceneById</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.getDownloadURL" href="#adeskForgeWrapper.RealityCapture.Photoscene.getDownloadURL">getDownloadURL</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.getProgress" href="#adeskForgeWrapper.RealityCapture.Photoscene.getProgress">getProgress</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.psById" href="#adeskForgeWrapper.RealityCapture.Photoscene.psById">psById</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.startProcessing" href="#adeskForgeWrapper.RealityCapture.Photoscene.startProcessing">startProcessing</a></code></li>
<li><code><a title="adeskForgeWrapper.RealityCapture.Photoscene.uploadFiles" href="#adeskForgeWrapper.RealityCapture.Photoscene.uploadFiles">uploadFiles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions" href="#adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions">PhotosceneCreationOptions</a></code></h4>
<ul class="">
<li><code><a title="adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions.defaultObjectScene" href="#adeskForgeWrapper.RealityCapture.PhotosceneCreationOptions.defaultObjectScene">defaultObjectScene</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>