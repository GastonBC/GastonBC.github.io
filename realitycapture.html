<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.0" />
<title>adeskForgeWrapper.realitycapture API documentation</title>
<meta name="description" content="Module for the Reality Capture API" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>adeskForgeWrapper.realitycapture</code></h1>
</header>
<section id="section-intro">
<p>Module for the Reality Capture API</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Module for the Reality Capture API&#39;&#39;&#39;
from .utils import checkScopes
from .utils import checkResponse
from .utils import RECAP_API
from .utils import batch
from . import client
from . import AFWExceptions
import json

from requests_toolbelt import MultipartEncoder
import requests

class Options(object):
    &#39;&#39;&#39;Class used to organize request options for this module&#39;&#39;&#39;
    @staticmethod
    def create_scene_options(scenename, Format = &#34;rcm&#34;, scenetype = &#34;aerial&#34;, callback = None, gpstype = None, hubprojectid = None,
                hubfolderid = None, version = &#34;2.0&#34;, metadata = None):
        &#39;&#39;&#39;Options for Photoscene.create&#39;&#39;&#39;

        if scenetype != &#34;aerial&#34;:
            if Format == &#34;rcs&#34; or Format == &#34;ortho&#34; or Format == &#34;report&#34;:
                raise AFWExceptions.AFWError(&#34;That format parameter is only available if scenetype is set to aerial&#34;)

            elif gpstype != None:
                pass #TODO Check 

            elif metadata != None:
                raise AFWExceptions.AFWError(&#34;Metadata fine tuning parameters are available only if scenetype is set to aerial&#34;)
        data = {
                &#34;scenename&#34; : scenename,
                &#34;callback&#34; : callback,
                &#34;format&#34;: Format,
                &#34;scenetype&#34; : scenetype,
                &#34;gpstype&#34; : gpstype,
                &#34;hubprojectid&#34; : hubprojectid,
                &#34;hubfolderid&#34; : hubfolderid,
                &#34;version&#34; : version,
                &#34;metadata&#34; : metadata
                }
        if callback is not None:
            if &#34;http://&#34; in callback or &#34;https://&#34; in callback:
                data[&#34;callback&#34;] = callback
            else:
                data[&#34;callback&#34;] = &#34;email://{}&#34;.format(callback)
        data = {k : v for k,v in data.items() if v is not None} 
        return data # Works as dict type. Returns an error using json.dumps, why...


class Photoscene(object):
    &#39;&#39;&#39;A “photoscene” entity provides a common representation of a photo-to-3D project. &lt;br&gt;
    Certain fields will only be available after processing is complete.&#39;&#39;&#39;
    def __init__(self, rawDict):
        self.__raw = rawDict

    @property
    def raw(self):
        return self.__raw
    @property
    def id(self):
        return self.__raw.get(&#34;photosceneid&#34;, None)
    @property
    def progressmsg(self):
        return self.__raw.get(&#34;progressmsg&#34;, None)
    @property
    def progress(self):
        return self.__raw.get(&#34;progress&#34;, None)
    @property
    def scenelink(self):
        return self.__raw.get(&#34;scenelink&#34;, None)
    @property
    def filesize(self):
        return self.__raw.get(&#34;filesize&#34;, None)
    @property
    def resultmsg(self):
        return self.__raw.get(&#34;resultmsg&#34;, None)

    @classmethod
    def photoscene_by_id(cls, PhotosceneId):
        rawDict = {
        &#34;Photoscene&#34;: {
        &#34;photosceneid&#34;: PhotosceneId
         }
        }
        return cls(rawDict)
    
    @classmethod
    def create_scene(cls, token: client.Token, create_scene_options):
        &#39;&#39;&#39;Creates and initializes a photoscene for reconstruction.&lt;br&gt;
        Scope - data:write
        psOptions - Options.PhotosceneCreationOptions&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene&#34;
        r = requests.post(endpointUrl, headers=token.urlEncoded, data=create_scene_options).json()
        checkResponse(r)
        print(&#34;Photoscene ID:&#34;, &#39;{}&#39;.format(r[&#39;Photoscene&#39;].get(&#34;photosceneid&#34;)))
        return cls(r)
    
    def upload_files(self, token: client.Token, files: list, batchSize=3):
        &#39;&#39;&#39;Adds one or more files to a photoscene.&lt;br&gt;
        Scope - data:write&lt;br&gt;
        files - A list containing the path to the images you want to upload&lt;br&gt;
        batchSize - Number of files per request must be limited to avoid timeouts&lt;br&gt;
        Recommended batch size 3 (default)&lt;br&gt;&lt;br&gt;

        Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
        Although uploading multiple files at the same time might be more efficient, you should limit the number 
        of files per request depending on your available bandwidth to avoid timeouts.&lt;br&gt;
        Note: Uploaded files will be deleted after 30 days.&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        filesUploaded=[]

        for x in batch(files, batchSize):
            n=-1
            fields = {&#39;photosceneid&#39;:self.id, &#39;type&#39;: &#39;image&#39;}
            for a in x:
                n=n+1
                a = a.replace(&#34;/&#34;, &#34;\\&#34;)
                fields[&#34;file[{x}]&#34;.format(x=n)] = (a, open(a,&#39;rb&#39;), &#39;image/jpg&#39;)

            payload = MultipartEncoder(fields)
            headers = {&#39;Content-Type&#39;: payload.content_type, &#39;Authorization&#39;: &#39;Bearer {}&#39;.format(token.access_token)}

            endpointUrl = RECAP_API+&#34;/file&#34;
            r = requests.post(endpointUrl, headers=headers, data=payload).json()
            if &#34;Error&#34; in r:
                checkResponse(r[&#34;Error&#34;])
            else:
                print(len(x), &#34;uploaded&#34;)
                for raw in r[&#34;Files&#34;][&#34;file&#34;]:
                    filesUploaded.append(File(raw, self.id))
        print(&#34;Success&#34;)
        return filesUploaded
        

    def start_processing(self, token: client.Token):
        &#39;&#39;&#39;Starts photoscene processing.&lt;br&gt;
        Scope - data:write&lt;br&gt;

        The main processing steps involve: camera calibration, mesh reconstruction, texturing, and any necessary output file format conversions, in that order.&lt;br&gt;
        This method should not be called until a photoscene has been created and at least three images have been added to the photoscene.&lt;br&gt;
        Note: Progress of the processing can be monitored with the getProgress(token)&lt;br&gt;
        Returns True if request was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(&#34;Processing started&#34;)
            return True

    def get_progress(self, token: client.Token):
        &#39;&#39;&#39;Returns the processing progress and status of a photoscene.&lt;br&gt;
        Scope - data:read&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/progress&#34;.format(phId = self.id)
        r = requests.get(endpointUrl, headers=token.getHeader).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(&#34;{}%&#34;.format(r[&#34;Photoscene&#34;][&#34;progress&#34;]))
            print(r[&#34;Photoscene&#34;][&#34;progressmsg&#34;])

    def delete_scene(self, token: client.Token):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&lt;br&gt;
        Scope - data:write&lt;br&gt;&lt;br&gt;
        
        Returns True if deletion was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Photoscene successfully deleted&#34;)

    @staticmethod
    def delete_scene_by_id(token: client.Token, Id: str):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...) by ID&lt;br&gt;
        Scope - data:write&lt;br&gt;&lt;br&gt;
        
        Returns True if deletion was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = Id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Photoscene successfully deleted&#34;)
            return True

    def get_download_url(self, token: client.Token, Format):
        &#39;&#39;&#39;Returns a time-limited HTTPS link to an output file of the specified format.&lt;br&gt;
        Scope - data:read&lt;br&gt;&lt;br&gt;
        Note: The link will expire 30 days after the date of processing completion.&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        params = {&#34;format&#34;:Format}
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
        r = requests.get(endpointUrl,headers=token.getHeader, params=params).json()
        print(r) # TODO Review attributes usability

    def cancel_progress(self, token: client.Token):
        &#39;&#39;&#39;Aborts the processing of a photoscene and marks it as cancelled.&lt;br&gt;
        Scope - data:write&lt;br&gt;
        
        Returns True if cancel was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/cancel&#34;.format(phId = self.id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Cancel successful&#34;)
            return True


class File(object):
    &#39;&#39;&#39;Class for the files returned by uploadFiles()&#39;&#39;&#39;
    def __init__(self, rawDict, psId):
        self.Id = rawDict.get(&#34;fileid&#34;)
        self.Name = rawDict.get(&#34;filename&#34;)
        self.Size = rawDict.get(&#34;filesize&#34;)
        self.PhotosceneId = psId

__pdoc__ = {}

__pdoc__[&#39;Photoscene.raw&#39;] = False      
__pdoc__[&#39;Photoscene.scenename&#39;] = False
__pdoc__[&#39;Photoscene.callback&#39;] = False 
__pdoc__[&#39;Photoscene.format&#39;] = False   
__pdoc__[&#39;Photoscene.scenetype&#39;] = False
__pdoc__[&#39;Photoscene.gpstype&#39;] = False
__pdoc__[&#39;Photoscene.hubprojectid&#39;] = False
__pdoc__[&#39;Photoscene.hubfolderid&#39;] = False
__pdoc__[&#39;Photoscene.version&#39;] = False
__pdoc__[&#39;Photoscene.metadata&#39;] = False

__pdoc__[&#39;File.Id&#39;] = False
__pdoc__[&#39;File.Name&#39;] = False
__pdoc__[&#39;File.Size&#39;] = False
__pdoc__[&#39;File.PhotosceneId&#39;] = False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="adeskForgeWrapper.realitycapture.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>rawDict, psId)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for the files returned by uploadFiles()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File(object):
    &#39;&#39;&#39;Class for the files returned by uploadFiles()&#39;&#39;&#39;
    def __init__(self, rawDict, psId):
        self.Id = rawDict.get(&#34;fileid&#34;)
        self.Name = rawDict.get(&#34;filename&#34;)
        self.Size = rawDict.get(&#34;filesize&#34;)
        self.PhotosceneId = psId</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Options"><code class="flex name class">
<span>class <span class="ident">Options</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class used to organize request options for this module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Options(object):
    &#39;&#39;&#39;Class used to organize request options for this module&#39;&#39;&#39;
    @staticmethod
    def create_scene_options(scenename, Format = &#34;rcm&#34;, scenetype = &#34;aerial&#34;, callback = None, gpstype = None, hubprojectid = None,
                hubfolderid = None, version = &#34;2.0&#34;, metadata = None):
        &#39;&#39;&#39;Options for Photoscene.create&#39;&#39;&#39;

        if scenetype != &#34;aerial&#34;:
            if Format == &#34;rcs&#34; or Format == &#34;ortho&#34; or Format == &#34;report&#34;:
                raise AFWExceptions.AFWError(&#34;That format parameter is only available if scenetype is set to aerial&#34;)

            elif gpstype != None:
                pass #TODO Check 

            elif metadata != None:
                raise AFWExceptions.AFWError(&#34;Metadata fine tuning parameters are available only if scenetype is set to aerial&#34;)
        data = {
                &#34;scenename&#34; : scenename,
                &#34;callback&#34; : callback,
                &#34;format&#34;: Format,
                &#34;scenetype&#34; : scenetype,
                &#34;gpstype&#34; : gpstype,
                &#34;hubprojectid&#34; : hubprojectid,
                &#34;hubfolderid&#34; : hubfolderid,
                &#34;version&#34; : version,
                &#34;metadata&#34; : metadata
                }
        if callback is not None:
            if &#34;http://&#34; in callback or &#34;https://&#34; in callback:
                data[&#34;callback&#34;] = callback
            else:
                data[&#34;callback&#34;] = &#34;email://{}&#34;.format(callback)
        data = {k : v for k,v in data.items() if v is not None} 
        return data # Works as dict type. Returns an error using json.dumps, why...</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="adeskForgeWrapper.realitycapture.Options.create_scene_options"><code class="name flex">
<span>def <span class="ident">create_scene_options</span></span>(<span>scenename, Format='rcm', scenetype='aerial', callback=None, gpstype=None, hubprojectid=None, hubfolderid=None, version='2.0', metadata=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for Photoscene.create</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_scene_options(scenename, Format = &#34;rcm&#34;, scenetype = &#34;aerial&#34;, callback = None, gpstype = None, hubprojectid = None,
            hubfolderid = None, version = &#34;2.0&#34;, metadata = None):
    &#39;&#39;&#39;Options for Photoscene.create&#39;&#39;&#39;

    if scenetype != &#34;aerial&#34;:
        if Format == &#34;rcs&#34; or Format == &#34;ortho&#34; or Format == &#34;report&#34;:
            raise AFWExceptions.AFWError(&#34;That format parameter is only available if scenetype is set to aerial&#34;)

        elif gpstype != None:
            pass #TODO Check 

        elif metadata != None:
            raise AFWExceptions.AFWError(&#34;Metadata fine tuning parameters are available only if scenetype is set to aerial&#34;)
    data = {
            &#34;scenename&#34; : scenename,
            &#34;callback&#34; : callback,
            &#34;format&#34;: Format,
            &#34;scenetype&#34; : scenetype,
            &#34;gpstype&#34; : gpstype,
            &#34;hubprojectid&#34; : hubprojectid,
            &#34;hubfolderid&#34; : hubfolderid,
            &#34;version&#34; : version,
            &#34;metadata&#34; : metadata
            }
    if callback is not None:
        if &#34;http://&#34; in callback or &#34;https://&#34; in callback:
            data[&#34;callback&#34;] = callback
        else:
            data[&#34;callback&#34;] = &#34;email://{}&#34;.format(callback)
    data = {k : v for k,v in data.items() if v is not None} 
    return data # Works as dict type. Returns an error using json.dumps, why...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene"><code class="flex name class">
<span>class <span class="ident">Photoscene</span></span>
<span>(</span><span>rawDict)</span>
</code></dt>
<dd>
<div class="desc"><p>A “photoscene” entity provides a common representation of a photo-to-3D project. <br>
Certain fields will only be available after processing is complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Photoscene(object):
    &#39;&#39;&#39;A “photoscene” entity provides a common representation of a photo-to-3D project. &lt;br&gt;
    Certain fields will only be available after processing is complete.&#39;&#39;&#39;
    def __init__(self, rawDict):
        self.__raw = rawDict

    @property
    def raw(self):
        return self.__raw
    @property
    def id(self):
        return self.__raw.get(&#34;photosceneid&#34;, None)
    @property
    def progressmsg(self):
        return self.__raw.get(&#34;progressmsg&#34;, None)
    @property
    def progress(self):
        return self.__raw.get(&#34;progress&#34;, None)
    @property
    def scenelink(self):
        return self.__raw.get(&#34;scenelink&#34;, None)
    @property
    def filesize(self):
        return self.__raw.get(&#34;filesize&#34;, None)
    @property
    def resultmsg(self):
        return self.__raw.get(&#34;resultmsg&#34;, None)

    @classmethod
    def photoscene_by_id(cls, PhotosceneId):
        rawDict = {
        &#34;Photoscene&#34;: {
        &#34;photosceneid&#34;: PhotosceneId
         }
        }
        return cls(rawDict)
    
    @classmethod
    def create_scene(cls, token: client.Token, create_scene_options):
        &#39;&#39;&#39;Creates and initializes a photoscene for reconstruction.&lt;br&gt;
        Scope - data:write
        psOptions - Options.PhotosceneCreationOptions&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene&#34;
        r = requests.post(endpointUrl, headers=token.urlEncoded, data=create_scene_options).json()
        checkResponse(r)
        print(&#34;Photoscene ID:&#34;, &#39;{}&#39;.format(r[&#39;Photoscene&#39;].get(&#34;photosceneid&#34;)))
        return cls(r)
    
    def upload_files(self, token: client.Token, files: list, batchSize=3):
        &#39;&#39;&#39;Adds one or more files to a photoscene.&lt;br&gt;
        Scope - data:write&lt;br&gt;
        files - A list containing the path to the images you want to upload&lt;br&gt;
        batchSize - Number of files per request must be limited to avoid timeouts&lt;br&gt;
        Recommended batch size 3 (default)&lt;br&gt;&lt;br&gt;

        Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
        Although uploading multiple files at the same time might be more efficient, you should limit the number 
        of files per request depending on your available bandwidth to avoid timeouts.&lt;br&gt;
        Note: Uploaded files will be deleted after 30 days.&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        filesUploaded=[]

        for x in batch(files, batchSize):
            n=-1
            fields = {&#39;photosceneid&#39;:self.id, &#39;type&#39;: &#39;image&#39;}
            for a in x:
                n=n+1
                a = a.replace(&#34;/&#34;, &#34;\\&#34;)
                fields[&#34;file[{x}]&#34;.format(x=n)] = (a, open(a,&#39;rb&#39;), &#39;image/jpg&#39;)

            payload = MultipartEncoder(fields)
            headers = {&#39;Content-Type&#39;: payload.content_type, &#39;Authorization&#39;: &#39;Bearer {}&#39;.format(token.access_token)}

            endpointUrl = RECAP_API+&#34;/file&#34;
            r = requests.post(endpointUrl, headers=headers, data=payload).json()
            if &#34;Error&#34; in r:
                checkResponse(r[&#34;Error&#34;])
            else:
                print(len(x), &#34;uploaded&#34;)
                for raw in r[&#34;Files&#34;][&#34;file&#34;]:
                    filesUploaded.append(File(raw, self.id))
        print(&#34;Success&#34;)
        return filesUploaded
        

    def start_processing(self, token: client.Token):
        &#39;&#39;&#39;Starts photoscene processing.&lt;br&gt;
        Scope - data:write&lt;br&gt;

        The main processing steps involve: camera calibration, mesh reconstruction, texturing, and any necessary output file format conversions, in that order.&lt;br&gt;
        This method should not be called until a photoscene has been created and at least three images have been added to the photoscene.&lt;br&gt;
        Note: Progress of the processing can be monitored with the getProgress(token)&lt;br&gt;
        Returns True if request was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(&#34;Processing started&#34;)
            return True

    def get_progress(self, token: client.Token):
        &#39;&#39;&#39;Returns the processing progress and status of a photoscene.&lt;br&gt;
        Scope - data:read&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/progress&#34;.format(phId = self.id)
        r = requests.get(endpointUrl, headers=token.getHeader).json()
        checkResponse(r)
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(&#34;{}%&#34;.format(r[&#34;Photoscene&#34;][&#34;progress&#34;]))
            print(r[&#34;Photoscene&#34;][&#34;progressmsg&#34;])

    def delete_scene(self, token: client.Token):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&lt;br&gt;
        Scope - data:write&lt;br&gt;&lt;br&gt;
        
        Returns True if deletion was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Photoscene successfully deleted&#34;)

    @staticmethod
    def delete_scene_by_id(token: client.Token, Id: str):
        &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...) by ID&lt;br&gt;
        Scope - data:write&lt;br&gt;&lt;br&gt;
        
        Returns True if deletion was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = Id)
        r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Photoscene successfully deleted&#34;)
            return True

    def get_download_url(self, token: client.Token, Format):
        &#39;&#39;&#39;Returns a time-limited HTTPS link to an output file of the specified format.&lt;br&gt;
        Scope - data:read&lt;br&gt;&lt;br&gt;
        Note: The link will expire 30 days after the date of processing completion.&#39;&#39;&#39;
        checkScopes(token, &#34;data:read&#34;)
        params = {&#34;format&#34;:Format}
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
        r = requests.get(endpointUrl,headers=token.getHeader, params=params).json()
        print(r) # TODO Review attributes usability

    def cancel_progress(self, token: client.Token):
        &#39;&#39;&#39;Aborts the processing of a photoscene and marks it as cancelled.&lt;br&gt;
        Scope - data:write&lt;br&gt;
        
        Returns True if cancel was successful&#39;&#39;&#39;
        checkScopes(token, &#34;data:write&#34;)
        endpointUrl = RECAP_API+&#34;/photoscene/{phId}/cancel&#34;.format(phId = self.id)
        r = requests.post(endpointUrl, headers=token.urlEncoded).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        elif r[&#34;msg&#34;] == &#34;No error&#34;:
            print(&#34;Cancel successful&#34;)
            return True</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.create_scene"><code class="name flex">
<span>def <span class="ident">create_scene</span></span>(<span>token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, create_scene_options)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and initializes a photoscene for reconstruction.<br>
Scope - data:write
psOptions - Options.PhotosceneCreationOptions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_scene(cls, token: client.Token, create_scene_options):
    &#39;&#39;&#39;Creates and initializes a photoscene for reconstruction.&lt;br&gt;
    Scope - data:write
    psOptions - Options.PhotosceneCreationOptions&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene&#34;
    r = requests.post(endpointUrl, headers=token.urlEncoded, data=create_scene_options).json()
    checkResponse(r)
    print(&#34;Photoscene ID:&#34;, &#39;{}&#39;.format(r[&#39;Photoscene&#39;].get(&#34;photosceneid&#34;)))
    return cls(r)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.delete_scene_by_id"><code class="name flex">
<span>def <span class="ident">delete_scene_by_id</span></span>(<span>token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, Id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a photoscene and its associated assets (images, output files, &hellip;) by ID<br>
Scope - data:write<br><br></p>
<p>Returns True if deletion was successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delete_scene_by_id(token: client.Token, Id: str):
    &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...) by ID&lt;br&gt;
    Scope - data:write&lt;br&gt;&lt;br&gt;
    
    Returns True if deletion was successful&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = Id)
    r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    elif r[&#34;msg&#34;] == &#34;No error&#34;:
        print(&#34;Photoscene successfully deleted&#34;)
        return True</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.photoscene_by_id"><code class="name flex">
<span>def <span class="ident">photoscene_by_id</span></span>(<span>PhotosceneId)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def photoscene_by_id(cls, PhotosceneId):
    rawDict = {
    &#34;Photoscene&#34;: {
    &#34;photosceneid&#34;: PhotosceneId
     }
    }
    return cls(rawDict)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.filesize"><code class="name">var <span class="ident">filesize</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filesize(self):
    return self.__raw.get(&#34;filesize&#34;, None)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    return self.__raw.get(&#34;photosceneid&#34;, None)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def progress(self):
    return self.__raw.get(&#34;progress&#34;, None)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.progressmsg"><code class="name">var <span class="ident">progressmsg</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def progressmsg(self):
    return self.__raw.get(&#34;progressmsg&#34;, None)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.resultmsg"><code class="name">var <span class="ident">resultmsg</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resultmsg(self):
    return self.__raw.get(&#34;resultmsg&#34;, None)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.scenelink"><code class="name">var <span class="ident">scenelink</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scenelink(self):
    return self.__raw.get(&#34;scenelink&#34;, None)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.cancel_progress"><code class="name flex">
<span>def <span class="ident">cancel_progress</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Aborts the processing of a photoscene and marks it as cancelled.<br>
Scope - data:write<br></p>
<p>Returns True if cancel was successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_progress(self, token: client.Token):
    &#39;&#39;&#39;Aborts the processing of a photoscene and marks it as cancelled.&lt;br&gt;
    Scope - data:write&lt;br&gt;
    
    Returns True if cancel was successful&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}/cancel&#34;.format(phId = self.id)
    r = requests.post(endpointUrl, headers=token.urlEncoded).json()
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    elif r[&#34;msg&#34;] == &#34;No error&#34;:
        print(&#34;Cancel successful&#34;)
        return True</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.delete_scene"><code class="name flex">
<span>def <span class="ident">delete_scene</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a photoscene and its associated assets (images, output files, &hellip;).<br>
Scope - data:write<br><br></p>
<p>Returns True if deletion was successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_scene(self, token: client.Token):
    &#39;&#39;&#39;Deletes a photoscene and its associated assets (images, output files, ...).&lt;br&gt;
    Scope - data:write&lt;br&gt;&lt;br&gt;
    
    Returns True if deletion was successful&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
    r = requests.delete(endpointUrl,headers=token.urlEncoded).json()
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    elif r[&#34;msg&#34;] == &#34;No error&#34;:
        print(&#34;Photoscene successfully deleted&#34;)</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.get_download_url"><code class="name flex">
<span>def <span class="ident">get_download_url</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, Format)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a time-limited HTTPS link to an output file of the specified format.<br>
Scope - data:read<br><br>
Note: The link will expire 30 days after the date of processing completion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_download_url(self, token: client.Token, Format):
    &#39;&#39;&#39;Returns a time-limited HTTPS link to an output file of the specified format.&lt;br&gt;
    Scope - data:read&lt;br&gt;&lt;br&gt;
    Note: The link will expire 30 days after the date of processing completion.&#39;&#39;&#39;
    checkScopes(token, &#34;data:read&#34;)
    params = {&#34;format&#34;:Format}
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
    r = requests.get(endpointUrl,headers=token.getHeader, params=params).json()
    print(r) # TODO Review attributes usability</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.get_progress"><code class="name flex">
<span>def <span class="ident">get_progress</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the processing progress and status of a photoscene.<br>
Scope - data:read</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_progress(self, token: client.Token):
    &#39;&#39;&#39;Returns the processing progress and status of a photoscene.&lt;br&gt;
    Scope - data:read&#39;&#39;&#39;
    checkScopes(token, &#34;data:read&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}/progress&#34;.format(phId = self.id)
    r = requests.get(endpointUrl, headers=token.getHeader).json()
    checkResponse(r)
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    else:
        print(&#34;{}%&#34;.format(r[&#34;Photoscene&#34;][&#34;progress&#34;]))
        print(r[&#34;Photoscene&#34;][&#34;progressmsg&#34;])</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.start_processing"><code class="name flex">
<span>def <span class="ident">start_processing</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts photoscene processing.<br>
Scope - data:write<br></p>
<p>The main processing steps involve: camera calibration, mesh reconstruction, texturing, and any necessary output file format conversions, in that order.<br>
This method should not be called until a photoscene has been created and at least three images have been added to the photoscene.<br>
Note: Progress of the processing can be monitored with the getProgress(token)<br>
Returns True if request was successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_processing(self, token: client.Token):
    &#39;&#39;&#39;Starts photoscene processing.&lt;br&gt;
    Scope - data:write&lt;br&gt;

    The main processing steps involve: camera calibration, mesh reconstruction, texturing, and any necessary output file format conversions, in that order.&lt;br&gt;
    This method should not be called until a photoscene has been created and at least three images have been added to the photoscene.&lt;br&gt;
    Note: Progress of the processing can be monitored with the getProgress(token)&lt;br&gt;
    Returns True if request was successful&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    endpointUrl = RECAP_API+&#34;/photoscene/{phId}&#34;.format(phId = self.id)
    r = requests.post(endpointUrl, headers=token.urlEncoded).json()
    checkResponse(r)
    if &#34;Error&#34; in r:
        checkResponse(r[&#34;Error&#34;])
    else:
        print(&#34;Processing started&#34;)
        return True</code></pre>
</details>
</dd>
<dt id="adeskForgeWrapper.realitycapture.Photoscene.upload_files"><code class="name flex">
<span>def <span class="ident">upload_files</span></span>(<span>self, token: <a title="adeskForgeWrapper.client.Token" href="client.html#adeskForgeWrapper.client.Token">Token</a>, files: list, batchSize=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more files to a photoscene.<br>
Scope - data:write<br>
files - A list containing the path to the images you want to upload<br>
batchSize - Number of files per request must be limited to avoid timeouts<br>
Recommended batch size 3 (default)<br><br></p>
<p>Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
Although uploading multiple files at the same time might be more efficient, you should limit the number
of files per request depending on your available bandwidth to avoid timeouts.<br>
Note: Uploaded files will be deleted after 30 days.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_files(self, token: client.Token, files: list, batchSize=3):
    &#39;&#39;&#39;Adds one or more files to a photoscene.&lt;br&gt;
    Scope - data:write&lt;br&gt;
    files - A list containing the path to the images you want to upload&lt;br&gt;
    batchSize - Number of files per request must be limited to avoid timeouts&lt;br&gt;
    Recommended batch size 3 (default)&lt;br&gt;&lt;br&gt;

    Files can be added to photoscene either by uploading them directly or by providing public HTTP/HTTPS links.
    Although uploading multiple files at the same time might be more efficient, you should limit the number 
    of files per request depending on your available bandwidth to avoid timeouts.&lt;br&gt;
    Note: Uploaded files will be deleted after 30 days.&#39;&#39;&#39;
    checkScopes(token, &#34;data:write&#34;)
    filesUploaded=[]

    for x in batch(files, batchSize):
        n=-1
        fields = {&#39;photosceneid&#39;:self.id, &#39;type&#39;: &#39;image&#39;}
        for a in x:
            n=n+1
            a = a.replace(&#34;/&#34;, &#34;\\&#34;)
            fields[&#34;file[{x}]&#34;.format(x=n)] = (a, open(a,&#39;rb&#39;), &#39;image/jpg&#39;)

        payload = MultipartEncoder(fields)
        headers = {&#39;Content-Type&#39;: payload.content_type, &#39;Authorization&#39;: &#39;Bearer {}&#39;.format(token.access_token)}

        endpointUrl = RECAP_API+&#34;/file&#34;
        r = requests.post(endpointUrl, headers=headers, data=payload).json()
        if &#34;Error&#34; in r:
            checkResponse(r[&#34;Error&#34;])
        else:
            print(len(x), &#34;uploaded&#34;)
            for raw in r[&#34;Files&#34;][&#34;file&#34;]:
                filesUploaded.append(File(raw, self.id))
    print(&#34;Success&#34;)
    return filesUploaded</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="adeskForgeWrapper" href="index.html">adeskForgeWrapper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="adeskForgeWrapper.realitycapture.File" href="#adeskForgeWrapper.realitycapture.File">File</a></code></h4>
</li>
<li>
<h4><code><a title="adeskForgeWrapper.realitycapture.Options" href="#adeskForgeWrapper.realitycapture.Options">Options</a></code></h4>
<ul class="">
<li><code><a title="adeskForgeWrapper.realitycapture.Options.create_scene_options" href="#adeskForgeWrapper.realitycapture.Options.create_scene_options">create_scene_options</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="adeskForgeWrapper.realitycapture.Photoscene" href="#adeskForgeWrapper.realitycapture.Photoscene">Photoscene</a></code></h4>
<ul class="two-column">
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.cancel_progress" href="#adeskForgeWrapper.realitycapture.Photoscene.cancel_progress">cancel_progress</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.create_scene" href="#adeskForgeWrapper.realitycapture.Photoscene.create_scene">create_scene</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.delete_scene" href="#adeskForgeWrapper.realitycapture.Photoscene.delete_scene">delete_scene</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.delete_scene_by_id" href="#adeskForgeWrapper.realitycapture.Photoscene.delete_scene_by_id">delete_scene_by_id</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.filesize" href="#adeskForgeWrapper.realitycapture.Photoscene.filesize">filesize</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.get_download_url" href="#adeskForgeWrapper.realitycapture.Photoscene.get_download_url">get_download_url</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.get_progress" href="#adeskForgeWrapper.realitycapture.Photoscene.get_progress">get_progress</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.id" href="#adeskForgeWrapper.realitycapture.Photoscene.id">id</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.photoscene_by_id" href="#adeskForgeWrapper.realitycapture.Photoscene.photoscene_by_id">photoscene_by_id</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.progress" href="#adeskForgeWrapper.realitycapture.Photoscene.progress">progress</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.progressmsg" href="#adeskForgeWrapper.realitycapture.Photoscene.progressmsg">progressmsg</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.resultmsg" href="#adeskForgeWrapper.realitycapture.Photoscene.resultmsg">resultmsg</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.scenelink" href="#adeskForgeWrapper.realitycapture.Photoscene.scenelink">scenelink</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.start_processing" href="#adeskForgeWrapper.realitycapture.Photoscene.start_processing">start_processing</a></code></li>
<li><code><a title="adeskForgeWrapper.realitycapture.Photoscene.upload_files" href="#adeskForgeWrapper.realitycapture.Photoscene.upload_files">upload_files</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>